{-# LANGUAGE OverloadedStrings #-}

module Coreutils.Split where

-- split
--
-- break a file into chunks by line or byte count

import           Control.Monad
import           Coreutils.Util
import qualified Data.ByteString.Lazy       as L
import           Data.Char
import           Data.List
import           System.Console.GetOpt
import           System.Exit
import           System.IO
import           Text.Read

data Split = Split

instance Util Split where
    run _ = splitMain

data Runtime = NoRuntime | RunBytes Int | RunLines Int | RunChunk Int
    deriving (Show, Eq)

data File = File Handle (Maybe Integer)

data Options = Options
        { optSuffixLength :: Int
        , optExtraSuffix  :: String
        , optNumeric      :: Bool
        , optRuntime      :: Runtime
        }

splitMain :: [String] -> IO ()
-- parse arguments and check for obvious errors
splitMain args = do
        let (actions, files, errors) = getOpt RequireOrder options args

        unless (null errors) $ do
            mapM_ putStr errors
            exitFailure

        (prefix, file) <- case files of
            [] ->
                return ("x", File stdin Nothing)

            [fn] ->
                (,) "x" <$> getHandleAndSize fn

            [fn, prefix] ->
                (,) prefix <$> getHandleAndSize fn

            _ ->
                die "split cannot operate on more than one file at a time"

        case foldM (flip id) defaults actions of
            Left err   -> die err
            Right opts -> runSplit opts file prefix
    where
        getHandleAndSize :: String -> IO File
        getHandleAndSize "-" = pure $ File stdin Nothing
        getHandleAndSize fn = do
                h <- openBinaryFile fn ReadMode
                size <- hFileSize h
                pure $ File h (Just size)

runSplit :: Options -> File -> String -> IO ()
-- switchboard, this is where we apply the default runtime if needed too
runSplit opts@(Options s e n r) file prefix =
        case r of
            NoRuntime  -> runSplit (opts { optRuntime = RunLines 1000}) file prefix
            RunBytes v -> splitBytes file v filenames
            RunLines v -> splitLines file v filenames
            RunChunk v -> splitChunk file v filenames
    where
        filenames = map (\a -> prefix <> a) $ suffixGenerator n s e

splitBytes :: File -> Int -> [FilePath] -> IO ()
-- simplest split, just by byte ranges
splitBytes _ _ [] =
        die "split could not generate any more output filenames"

splitBytes f@(File h _) n (fn:fs) = do
        L.hGet h n >>= L.writeFile fn
        done <- hIsEOF h
        unless done $ splitBytes f n fs

splitLines :: File -> Int -> [FilePath] -> IO ()
splitLines (File h _) n paths =
        L.split newline <$> L.hGetContents h >>= go paths
    where
        go :: [FilePath] -> [L.ByteString] -> IO ()
        go _ [] = pure ()

        go [] _ =
            die "split could not generate any more output filenames"

        go (fn:fs) bs = do
            L.writeFile fn $ L.intercalate "\n" $ take n bs
            go fs (drop n bs)

        newline = 10

splitChunk :: File -> Int -> [String] -> IO ()
splitChunk _ _ [] =
        die "split could not generate any more output filenames"
splitChunk _ _ _ = undefined

-- | helpers

adjustment :: String -> Maybe Int
-- convert 10K  to 10240 (10 * 1024), etc
-- convert 10KB to 10000 (10 * 1000), etc
adjustment xs = case span isNumber characters of
        ("", _)       -> Nothing
        (ys, "")      -> Just $ read ys
        (ys, [v,'b']) -> (* read ys) <$> adjust v 1024
        (ys, [v])     -> (* read ys) <$> adjust v 1000
        _             -> Nothing
    where
        characters = map toLower xs

adjust :: Char -> Int -> Maybe Int
adjust n value = (\x -> value ^ (x + 1)) <$> elemIndex n "kmgtpezy"

suffixGenerator :: Bool -> Int -> String -> [String]
-- ^ lazy infinite list of suffixes that conform to these options. if more suffixes are
-- required than can be generated by the arguments provided, this calls itself with the
-- width increased by 1, making an infinite list
suffixGenerator numeric width extra =
        intended <> additional
    where
        intended = map (<> extra) $ replicateM width characters
        additional = suffixGenerator numeric (width + 1) extra

        characters
            | numeric   = concatMap show ([0..9] :: [Integer])
            | otherwise = ['a'..'z']

-- | options parsing

defaults :: Options
defaults = Options
        { optSuffixLength = 2
        , optExtraSuffix  = ""
        , optNumeric      = False
        , optRuntime      = NoRuntime
        }

options :: [OptDescr (Options -> Either String Options)]
options =
    [ Option "a" ["suffix-length"]
        (ReqArg
            (\arg opt -> case readMaybe arg of
                Nothing  -> Left $ "could not parse " <> arg <> " as a number"
                (Just n) -> Right opt { optSuffixLength = n })
            "N")
        "generate suffixes of length N (default 2)"

    , Option "" ["additional-suffix"]
        (ReqArg
            (\arg opt -> Right opt { optExtraSuffix = arg })
            "SUFFIX")
        "append an additional suffix to file names"

    , Option "d" []
        (NoArg
            (\opt -> Right opt { optNumeric = True}))
        "use numeric suffixes starting at 0, not alphabetic"

    , Option "b" ["bytes"]
        (ReqArg
            (\arg opt -> case adjustment arg of
                Nothing  -> Left $ "could not parse " <> arg <> " as a size"
                (Just n) -> Right opt { optRuntime = RunBytes n})
            "SIZE")
        "put SIZE bytes per output file"

    , Option "l" ["lines"]
        (ReqArg
            (\arg opt -> case readMaybe arg of
                Nothing  -> Left $ "could not parse " <> arg <> " as a number"
                (Just n) -> Right opt { optRuntime = RunLines n})
            "NUMBER")
        "put NUMBER lines/records per output file"

    , Option "n" ["number"]
        (ReqArg
            (\arg opt -> case readMaybe arg of
                Nothing  -> Left $ "could not parse " <> arg <> " as a number"
                (Just n) -> Right opt { optRuntime = RunChunk n})
            "CHUNKS")
        "generate CHUNKS output files"

    , Option "h" ["help"]
        (NoArg
            (\_ -> Left $ usageInfo "split" options))
        "Show this help text"
    ]
